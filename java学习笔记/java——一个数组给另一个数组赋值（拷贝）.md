## java——一个数组给另一个数组赋值（拷贝）

本文探讨Java中数组中的赋值问题。在探讨这个问题之前必须先弄懂一件事，Java中的数组到底是什么东西？是类，是对象，还是什么其他奇奇怪怪的东西。答案是：Java中的数组本质上是对象。但是这个对象不是通过某个类实例化来的，而是JVM创建的，这也就不难解释对于一个数组对象arr，我们可以直接通过arr.length访问数组的长度。

现在我们知道了Java中数组本质上是对象，那么我们来看一下这样的代码合理不合理：

```java
int[] a = {1,2,3};

int[] b = new int[3];

b = a;

for(int i = 0; i < a.length; i++)

a[i] = 0;
```

​        我们本来的想法是把a数组的值赋值给b，然后将a数组清零，但是我们会发现a，b数组都被清零了。
​    既然数组本质是对象，那么我们来分析一下这两句代码在Java内存模型中发生了什么。

int[] a = {1,2,3};的时候，堆中会生成一个对应的对象，a会指向这个对象，然后int[] b = new int[3];的时候，b也会指向这个对象。那么比如我们在对a[0]进行修改的时候，实际上是对堆中对象做出了修改。b数组仍然是指向这个堆中对象的，当然b数组的值也改变了。

说到这里已经显而易见了，这样实际上不太合理，比较两个引用都是指向同一个堆中对象，其中一个修改必然会导致另一个的修改。

那么数组的赋值究竟应该怎么做呢？

一、使用for循环

```java
int[] a = {1,2,3};

int[] b = new int[3];

for(int i = 0; i<a.length; i++)

b[i] = a[i];
```

​    这样可以实现赋值操作，而且灵活性不错，但是效率是个问题。

 

二、使用Object的clone()

既然数组本质是对象，那么他就有clone()方法。我们可以使用clone()方法进行复制：

```java
int[] a={1,2,3};

int[] b=(int[]) a.clone();//别忘了强制类型转换
```

三、使用System的静态方法arraycopy()

 

System提供了一个静态方法arraycopy(),原型如下：

public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)

src:源数组

srcPos:源数组要复制的起始位置
dest:目的数组

destPos:目的数组放置的起始位置
length:复制的长度

我们可以用它来进行数组之间的复制:

```java
int[] a ={1,2,3};

int[] b = new int[3];

System.arraycopy(a,0,b,0,3);
```

​    这个方法效率很高，而且具有一定的灵活性。许多基于数组实现的Java的集合类底层在数组复制的时候都是使用这个方法。